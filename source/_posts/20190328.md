---
title: 随笔-20190328
date: 2019-03-28 14:26:12
tags: 
    - 面试
    - 随笔
---

**1. Linux常用操作命令**

```shell
sed
awk
grep
ps
netstat/ss
ip/ifconfig
top
df
cat/more/less/tail/head
fdisk
find
uname
```

**2. 硬链接和软连接**

```
硬链接和软链接的区别

1.原理上：

硬链接(hard link)：文件A是文件B的硬链接，则A的目录项中的inode节点号与B的目录项中的inode节点号相同，即一个inode节点对应两个不同的文件名，两个文件名指向同一个文件，A和B对文件系统来说是完全平等的。如果删除了其中一个，对另外一个没有影响。每增加一个文件名，inode节点上的链接数增加一，每删除一个对应的文件名，inode节点上的链接数减一，直到为0，inode节点和对应的数据块被回收。注：文件和文件名是不同的东西，rm A删除的只是A这个文件名，而A对应的数据块（文件）只有在inode节点链接数减少为0的时候才会被系统回收。

软链接(soft link)：A是B的软链接（A和B都是文件名），A的目录项中的inode节点号与B的目录项中的inode节点号不相同，A和B指向的是两个不同的inode，继而指向两块不同的数据块。但是A的数据块中存放的只是B的路径名（可以根据这个找到B的目录项）。A和B之间是“主从”关系，如果B被删除了，A仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。

2.使用限制上：

硬链接：
a：不能对目录创建硬链接，原因有几种，最重要的是：文件系统不能存在链接环（目录创建时的”..”除外，这个系统可以识别出来）,存在环的后果会导致例如文件遍历等操作的混乱(du，pwd等命令的运作原理就是基于文件硬链接，顺便一提，ls -l结果的第二列也是文件的硬链接数，即inode节点的链接数)
b：不能对不同的文件系统创建硬链接,即两个文件名要在相同的文件系统下。
c：不能对不存在的文件创建硬链接，由原理即可知原因。

软链接：
a.可以对目录创建软链接，遍历操作会忽略目录的软链接。
b:可以跨文件系统
c:可以对不存在的文件创建软链接，因为放的只是一个字符串，至于这个字符串是不是对于一个实际的文件，就是另外一回事了

3.命令

硬链接：ln 源文件名 链接名
软链接：ln -s 源文件名 链接名

4.硬链接和软链接的作用

硬链接：
硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。只删除一个连接并不影响节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。

还有如果把链接名创建为一个以.开头的隐藏文件，还能很好的隐藏自己的隐私（你们懂的..呵呵呵）。

软链接：
软链接又称之为符号连接（Symbolic Link）。软链接文件类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。


```

**3. 大文件删除后空间未释放**

```
（1）在一台配置较低的Linux服务器（内存、硬盘比较小）的/data分区内创建文件时，系统提示磁盘空间不足，用df -h命令查看了一下磁盘使用情况，发现/data分区只使用了66%，还有12G的剩余空间，按理说不会出现这种问题。 后来用df -i查看了一下/data分区的索引节点(inode)，发现已经用满(IUsed=100%)，导致系统无法创建新目录和文件。 

查找原因：
　　/data/cache目录中存在数量非常多的小字节缓存文件，占用的Block不多，但是占用了大量的inode。 

解决方案：
　　1、删除/data/cache目录中的部分文件，释放出/data分区的一部分inode。
　　2、用软连接将空闲分区/opt中的newcache目录连接到/data/cache，使用/opt分区的inode来缓解/data分区inode不足的问题：
　　ln -s /opt/newcache /data/cache 

（2）现象：删除log后df看空间未释放

解决方案：
1.rm删除文件后，用lsof | grep XXX 查找使用该文件的进程，kill进程即可立即释放空间。
2.更好的方法是使用echo " ">file命令在线清空该文件。

lsof命令用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，因为lsof命令需要访问核心内存和各种文件，所以需要root用户执行。
```

**4. 数据库（mysql）的主从复制和双机热备**

```shell
#主从复制处理不同步
slave
```

**5. 数据库最大连接数配置、简单数据库优化**

```shell
#mysql最大连接数
set GLOBAL max_connections=200
show processlist


```

**6. 网络抓包**

```shell
#wireshark
wireshark使用pcap network library来进行封包捕捉。Lipcap（Linux）或者Winpcap（Windows）。
因为使用winpcap是直接进行网卡抓包的，所以Wireshark能够捕获到经过网卡的所有包，但是这样也造成在用wireshark对HTTPS包抓取的时候它只能抓到解析前的包数据，一般情况下不能直接解析，当然如果你一定要解析内容页是可以做到的，网上搜索一下也能找到相关的教程。
#fiddler
fiddler的实现方式和wireshark不同，它并不对网卡进行监听，而只是以代理web服务器的形式工作。它使用代理地址:127.0.0.1，端口:8888。当Fiddler退出的时候它会自动注销，这样就不会影响别的程序。他的实现方式也解释了为什么使用fiddler进行网络抓包的时候，当某些应用进行没有真实证书的https访问的时候，fiddler会有一个弹出框警示。
# 路由跟踪
tracerouter
```

**7. vi/vim操作快捷键**

```
1、vi的三种模式
命令（默认）、编辑、尾行

2、切换到编辑模式的四种方式，编辑模式可以输入任意内容
　　a 光标向后移动一位
　　i  当前位置
　　o 另起新行
　　s 删除光标所在字符
　　r 替换光标所在字符

3、尾行模式，用于保存内容、查找替换、设置行号等等功能性操作
　　:q　　  //quit退出vi编辑器
　　:w　　 //write保存修改的内容
　　:wq　　//保存并退出
　　:q!　　//强制退出，当对文本内容作了修改而不想要保存时
　　:w!　　//强制保存，当没有文本的写权限时
　　:set number　　或　　:set nu　　//显示行号
　　:set nonumber　　或　　:set nonu　　//取消显示行号 
　　:/内容/　　或　　/内容　　//查找指定内容　　//n将光标移动到下一个目标　　//N上一个
　　:n　　//跳转到第n行
　　:s/targetContent/newContent　　//替换当前行第一个targetContent为newContent
　　:s/targetContent/newContent/g　　//整行相应内容替换
　　:%s/targetContent/newContent  <==>　:1,$s/word1/word2/g　//整个文本相应内容替换     
　　:n1,n2s/word1/word2/gc　　　　　　//:100,200s/word1/word2/g   把100行到200行之间的word1替换为word2，并提示是否替换  c->confirm　

4、命令模式
　　1）光标移动
　　　　a、字符级
　　　　　　左（h）　　下（j）　　上（k）　　右（l）
　　　　b、单词级
　　　　　　w word移动到下个单词首字母
　　　　　　b before上个单词首字母
　　　　　　e end下个单词结尾
　　　　c、行级
　　　　　　0 行首
　　　　　　$ 行尾
　　　　d、段落级{ 上  } 下(没必要记忆)
　　　　e、屏幕级 H屏首　　L屏尾(没必要记忆)
　　　　f、文档级
　　　　　　G 文档尾部
　　　　　　nG 文档第n行
　　　　　　gg 文档第一行
　　　　　　crtl+f  <--> pagedown向下翻页
　　　　　　crtl+b <--> pageup向上翻页
　　　　　　n+enter      向下移动n行
　　2）内容删除
　　　　dd　　//删除当前行
　　　　ndd　　//自当前行向下删除n行
　　　　x　　//删除当前字符
　　　　cw　　//删除光标所在字母后面的字符
　　3）内容复制
　　　　yy　　//复制光标当前行
　　　　nyy　　//自当前行复制n行
　　　　p　　//对（删除）复制的内容进行粘贴
　　4）相关快捷操作
　　　　u　　//撤销
　　　　.　　//重复上次操作
```

**8. Django框架使用**

```
中间件（缓存机制mencache Redis）
高并发，大批量数据访问
```

**9. Docker和K8S**

```
crontab 是用来让使用者在固定时间或固定间隔执行程序之用，换句话说，也就是类似使用者的时程表。
容器导出（import/export元数据丢失），镜像导出（save/load保留历史）
容器生命周期管理
run
start/stop/restart
kill
rm
pause/unpause
create
exec
容器操作
ps
inspect
top
attach
events
logs
wait
export
port
容器rootfs命令
commit
cp
diff
镜像仓库
login
pull
push
search
本地镜像管理
images
rmi
tag
build
history
save
import
info|version
info
version
```

**10. Python**

```
多线程、
方法1：直接使用threading.Thread()
方法2：继承threading.Thread来自定义线程类，重写run方法
Join函数执行顺序是逐个执行每个线程，执行完毕后继续往下执行。主线程结束后，子线程还在运行，join函数使得主线程等到子线程结束时才退出。

多进程、
方法1：直接使用Process
方法2：继承Process来自定义进程类，重写run方法
Queue 是多进程安全的队列，可以实现多进程之间的数据传递。它主要有两个函数,put和get。

协程（yield）
根据维基百科给出的定义，“协程 是为非抢占式多任务产生子程序的计算机程序组件，协程允许不同入口点在不同位置暂停或开始执行程序”。从技术的角度来说，“协程就是你可以暂停执行的函数”。如果你把它理解成“就像生成器一样”，那么你就想对了。

GIL（全局解释锁）

先到先得

装饰器
简言之，python装饰器就是用于拓展原来函数功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数，使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。

类

异常捕获
try/except（捕获异常继续运行）
try/except/else
try/finally（退出try总会执行finally）
try/except/finally
raise（捕获到异常直接退出）

单例模式（实现__new__方法/共享属性/使用__metaclass__（元类））
```

**11. Shell**

```shell

```

**12. OpenStack**

```
horizon
nova
neutron
glance
cinder
swift
keystone

kvm/qemu
libvirt/virsh
openvswitch
vxlan、openflow、SDN、BGP
```

**13. 监控Nagios、Zabbix**

```

```

**14. Nginx、Tomcat、Apache**

```
缓存
代理/反向代理
负载均衡
集群
高可用
```

**15. 网络5/7层模型**

```
应用层（表示层，会话层）（ftp/http/https/dhcp）
传输层（tcp/udp）
网络层（ip）
数据链路层（mac）
物理层（物理连接）

```

**16. TCP三次握手四次断开**

```
置位概念：根据TCP的包头字段，存在三个重要的标识ACK、SYN、FIN
ACK：表示验证字段
SYN：位数置为1，表示建立TCP连接
FIN：位数置为1，表示断开TCP连接

1、TCP与UDP区别总结：

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。

3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5、TCP对系统资源要求较多，UDP对系统资源要求较少。


2、为什么UDP有时比TCP更有优势?

UDP以其简单、传输快的优势，在越来越多场景下取代了TCP,如实时游戏。
（1）网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。
（2）TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。

采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。

```

**17. FTP传输的两种模式**

```
FTP的两种连接方式：PORT模式和PASV模式，中文意思为主动式和被动式。

PORT（主动）模式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请求，服务器接受连接，建立一条命令链路。
工作原理：当需要传送数据时，客户端在命令链路上用 PORT命令告诉服务器：“我打开了**端口，你过来连接我”。当服务端收到这个Port命令后就会向客户端打开的那个端口发送连接请求，建立一条数据链路来传送数据。

PASV（被动）模式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请求，服务器接受连接，建立一条命令链路。
工作原理：需要传送数据时，服务器在命令链路上用 PASV命令告诉客户端：“我打开了**端口，你过来连接我”。当客户端收到这个信息后，就可以向服务端的端口发送连接请求，建立一条数据链路来传送数据。

FTP的两种传输方式：ASCII 和 BINARY

ASCII模式和Binary模式的区别是回车换行的处理，Binary模式不对数据进行任何处理，ASCII模式将回车换行转换为本机的回车字符，比如：UNIX下是\n,Windows下是\r\n，Mac下是\r。
ASCII模式下会转换文件，不能说是不同系统对回车换行解释不同，而是不同的系统有不同的行结束符。UNIX系统下行结束符是一个字节，即十六进制的0A，而Windows的系统是两个字节，即十六进制的0D0A，所以当你用ASCII方式从UNIX的FTP Server下载文件到Windows系统上时(不管是二进制或者文本文件)，每检测到一个字节是0A，就会自动插入一个0D，所以如果你的文件是二进制文件，比如可执行文件、压缩包什么的，就肯定不能用了。如果你的文件就是UNIX下的文本文件，你用ASCII模式是正确的，要是误用了Binary模式，你在Windows上看这个文件是没有换行的，里面是一个个的黑方块。
一般来说，我们最好都用Binary方式，这样可以保证不出错。如果有文本格式转换的问题，即UNIX格式的文本和DOS格式的文本之间的转换，有很多工具可以做的，不要在ftp传输的时候冒险，尤其是你如果对这些东西不是非常清楚的话。

如何设置FTP的传输方式呢？
在ftp>提示符下输入ascii即转换到ACSII方式，输入bin，即转换到Binary方式.
ftp> ascii
200 Type set to A.

ftp> bin
200 Type set to I.

```

**18. Ansible**

```
ansible 常用模块
1）主机连通性测试
2）command 模块
3）shell 模块
4）copy 模块
5）file 模块
6）fetch 模块
7）cron 模块
8）yum 模块
9）service 模块
10）user 模块
11）group 模块
12）script 模块
13）setup 模块
```

**19. 存储相关**

```
lvm
ceph
fastDFS
```

