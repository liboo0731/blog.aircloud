---
title: 【awk】命令回顾 - AWK
date: 2019-07-04 17:25:51
tags:
- awk
---

### AWK 语法

awk是一个报告生成器，它拥有强大的文本格式化的能力。

awk [ -F re][parameter...] ['prog'][-f progfile]
参数说明：

-F re：允许awk更改其字段分隔符。

parameter : 该参数帮助为不同的变量赋值。

'prog' : awk的程序语句段。这个语句段必须用单括号：'和'括起，以防被shell解释。这个程序语句段的标准形式为：

`'pattern {action}'`

其中pattern参数可以是egrep正则表达式中的任何一个，它可以使用语法/re/再加上一些样式匹配技巧构成。与sed类似，你也可以使用"," 分开两样式以选择某个范围。关于匹配的细节，你可以参考附录，如果仍不懂的话，找本UNIX书学学grep和sed（本人是在学习sed时掌握匹配技术的）。action参数总是被大括号包围，它由一系列awk语句组成，各语句之间用";"分隔。awk解释它们，并在pattern给定的样式匹配的记录上执行其操作。与shell类似，你也可以使用“#”作为注释符，它使“#”到行尾的内容成为注释，在解释执行时，它们将被忽略。你可以省略pattern和 action之一，但不能两者同时省略，当省略pattern时没有样式匹配，表示对所有行（记录）均执行操作，省略action时执行缺省的操作——在标准输出上显示。

-f progfile：允许awk调用并执行progfile指定有程序文件。progfile是一个文本文件，他必须符合awk的语法。

in_file : awk的输入文件，awk允许对多个输入文件进行处理。值得注意的是awk不修改输入文件。如果未指定输入文件，awk将接受标准输入，并将结果显示在标准输出上。awk支持输入输出重定向。



尽管操作可能会很复杂，但命令的语法始终是：

awk '{pattern + action}' 或者 awk 'pattern {action}'

**注意命令行中的程序是用单引号包围着的。这会防止shell解释程序中 $ 这样的字符，也允许程序的长度超过一行。**



grep 、sed、awk 被称为linux 中的 "三剑客"。

- grep 更适合单纯的查找或匹配文本
- sed  更适合编辑匹配到的文本
- awk  更适合格式化文本，对文本进行较复杂格式处理



### 内置变量

| **属性**    | **说明**                            |
| ----------- | ----------------------------------- |
| $0          | 当前记录（作为单个变量）            |
| $1~$n       | 当前记录的第n个字段，字段间由FS分隔 |
| FS          | 输入字段分隔符 默认是空格           |
| NF          | 当前记录中的字段个数，就是有多少列  |
| NR          | 已经读出的记录数，就是行号，从1开始 |
| RS          | 输入的记录他隔符默 认为换行符       |
| OFS         | 输出字段分隔符 默认也是空格         |
| ORS         | 输出的记录分隔符，默认为换行符      |
| ARGC        | 命令行参数个数                      |
| ARGV        | 命令行参数数组                      |
| FILENAME    | 当前输入文件的名字                  |
| IGNORECASE  | 如果为真，则进行忽略大小写的匹配    |
| ARGIND      | 当前被处理文件的ARGV标志符          |
| CONVFMT     | 数字转换格式 %.6g                   |
| ENVIRON     | UNIX环境变量                        |
| ERRNO       | UNIX系统错误消息                    |
| FIELDWIDTHS | 输入字段宽度的空白分隔字符串        |
| FNR         | 当前记录数                          |
| OFMT        | 数字的输出格式 %.6g                 |
| RSTART      | 被匹配函数匹配的字符串首            |
| RLENGTH     | 被匹配函数匹配的字符串长度          |
| SUBSEP      | \034                                |



### 内置字符串函数

| **函数**                            | **说明**                                                     |
| ----------------------------------- | ------------------------------------------------------------ |
| gsub( Ere, Repl, [ In ] )           | 除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行，。 |
| sub( Ere, Repl, [ In ] )            | 用 Repl 参数指定的字符串替换 In 参数指定的字符串中的由 Ere 参数指定的扩展正则表达式的第一个具体值。sub 函数返回替换的数量。出现在 Repl 参数指定的字符串中的 &（和符号）由 In 参数指定的与 Ere 参数的指定的扩展正则表达式匹配的字符串替换。如果未指定 In 参数，缺省值是整个记录（$0 记录变量）。 |
| index( String1, String2 )           | 在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零）。 |
| length [(String)]                   | 返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。 |
| blength [(String)]                  | 返回 String 参数指定的字符串的长度（以字节为单位）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。 |
| substr( String, M, [ N ] )          | 返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度。 |
| match( String, Ere )                | 在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）。 |
| split( String, A, [Ere] )           | 将 String 参数指定的参数分割为数组元素 A[1], A[2], . . ., A[n]，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建。 |
| tolower( String )                   | 返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。 |
| toupper( String )                   | 返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。 |
| sprintf(Format, Expr, Expr, . . . ) | 根据 Format 参数指定的 [printf](http://www.cnblogs.com/chengmo/admin/zh_CN/libs/basetrf1/printf.htm#a8zed0gaco) 子例程格式字符串来格式化 Expr 参数指定的表达式并返回最后生成的字符串。 |



### 字符串格式化

| **格式符** | **说明**                      |
| ---------- | ----------------------------- |
| %d         | 十进制有符号整数              |
| %u         | 十进制无符号整数              |
| %f         | 浮点数                        |
| %s         | 字符串                        |
| %c         | 单个字符                      |
| %p         | 指针的值                      |
| %e         | 指数形式的浮点数              |
| %x         | %X 无符号以十六进制表示的整数 |
| %o         | 无符号以八进制表示的整数      |
| %g         | 自动选择合适的表示法          |



### 实例

操作数据：

```
[root@host-172-16-2-221 ~]# cat emp.data 
Beth	4.00	0
Dan	3.75	0
kathy	4.00	10
Mark	5.00	20
Mary	5.50	22
Susie	4.25	18

```

简单操作：

```
[root@host-172-16-2-221 ~]# cat pattern 
BEGIN { print "Name    RATE    HOURS"; print ""}	# 字符处理开始时执行，可以定义分隔符（FS），定义初始变量等，多条语句用；隔开
      { print NR " line" }		# 行号
      { print NF " parts" }		# 这一行被分为几块
      { print $NF " last" }		# 最后一块内容
      { print "length: " length($1) }		# 第一项长度
      { print $0 }		# 整行
      { print "" }		# 空行
      { printf("%s-%s-%s", $1, $2, $3) }	# 格式化输出1,2,3项
      { pay += $2 * $3}		# 循环计算
      { pay = pay + $2 * $3}	# 同上
      { names = names $1 " "}	# 字符串连接
END   { print ""; print "over~" 
        print NR, "employees"
        print "total: " pay		# 循环结束后的结果
        print "average: " pay/NR
        print "Names: " names
      }

```



