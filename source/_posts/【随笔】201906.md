---
title: 【随笔】201906
date: 2019-06-19 21:55:44
tags:
- 随笔
- 201906
---

## 2019-6-20

```
问题：lvs+keepalived集群环境配置完成后通过vip无法访问web
1. 网卡上不存在vip
检查keepalived配置文件是否正确，keepalived服务是否正常启动。
2. 网卡上存在vip，但是无法访问
检查防火墙是否开启vip映射到RealServer的所有端口；检查所有RealServer的回环网卡及ARP配置是否正确。
3. 两边网卡都存在vip
两台主机不能正常通信，都把自己当成Master，检查防火墙是否配置vrrp规则


```

### 2019-6-19

```
HTTP 属于超文本传输协议，用来在 Internet 上传送超文本，而 HTTPS 为安全超文本传输协议，在 HTTPS 基础上拥有更强的安全性，简单来说 HTTPS 是 HTTP 的安全版，是使用 TLS/SSL 加密的 HTTP 协议。
HTTPS和HTTP的区别主要如下：
1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

OSI七层模型：
应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet
表示层 数据格式化，代码转换，数据加密 没有协议
会话层 解除或建立与别的接点的联系 没有协议
传输层 提供端对端的接口 TCP，UDP
网络层 为数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP
数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU
物理层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2

keepalived原理：
Layer3,4&7工作在IP/TCP协议栈的IP层，TCP层，及应用层,原理分别如下：

Layer3：Keepalived使用Layer3的方式工作式时，Keepalived会定期向服务器群中的服务器发送一个ICMP的数据包（既我们平时用的Ping程序）,如果发现某台服务的IP地址没有激活，Keepalived便报告这台服务器失效，并将它从服务器群中剔除，这种情况的典型例子是某台服务器被 非法关机。Layer3的方式是以服务器的IP地址是否有效作为服务器工作正常与否的标准。

Layer4:如果您理解了Layer3的方式，Layer4就容易了。Layer4主要以TCP端口的状态来决定服务器工作正常与否。如web server的服务端口一般是80，如果Keepalived检测到80端口没有启动，则Keepalived将把这台服务器从服务器群中剔除。

Layer7：Layer7就是工作在具体的应用层了，比Layer3,Layer4要复杂一点，在网络上占用的带宽也要大一些。Keepalived将根据用户的设定检查服务器程序的运行是否正常，如果与用户的设定不相符，则Keepalived将把服务器从服务器群中剔除。
```

## 2019-6-18

```
网卡状态查看
nmcli conn show
ethtool ens160
```

## 2019-6-14

```
function parseURL(url) {
    var a =  document.createElement('a');
    a.href = url;
    return {
        source: url,
        protocol: a.protocol.replace(':',''),
        host: a.hostname,
        port: a.port,
        query: a.search,
        params: (function(){
            var ret = {},
                seg = a.search.replace(/^\?/,'').split('&'),
                len = seg.length, i = 0, s;
            for (;i<len;i++) {
                if (!seg[i]) { continue; }
                s = seg[i].split('=');
                ret[s[0]] = s[1];
            }
            return ret;
        })(),
        file: (a.pathname.match(/\/([^\/?#]+)$/i) || [,''])[1],
        hash: a.hash.replace('#',''),
        path: a.pathname.replace(/^([^\/])/,'/$1'),
        relative: (a.href.match(/tps?:\/\/[^\/]+(.+)/) || [,''])[1],
        segments: a.pathname.replace(/^\//,'').split('/')
    };}
```

## 2019-6-13

```
docker kill $(docker ps -q) ; docker rm $(docker ps -a -q) ; docker rmi $(docker images -q -a)

echo `pwd`
echo $(pwd)
echo $(eval pwd)

```

## 2019-6-6

```
14台集群环境：
调度器
Director1（LVS1 + Keepalived1）
Director2（LVS2 + Keepalived2）
Web服务器
RealServer1
RealServer2
RealServer3
消息服务器
ActiveMQ1
ActiveMQ2
缓存服务器
Redis1
Redis2
数据库
MySQL1
MySQL2
分布式存储
FastDFS1
FastDFS2
预览服务器
Office1

1. redis在服务器断电时出现pid文件残留，系统重启后服务无法再次启动，需要清除pid文件才能启动成功
2. ActiveMQ依赖MySQL，但两个服务又不在同一个机器，如何确保服务正常启动？
3. LVS+Keepalived两台Director网卡都有VIP存在，关闭防火墙后正常

我来贴上解决方法吧，出现这问题的场景是在阿里VPS云服务器网络环境中，因为路由交换层禁用了ARP的广播限制，造成KEEPALIVE主备协议无法通过广播的方式进行通信，造成主备两台服务器都强占HAVIP地址，出现同时两台服务器都有VIP地址的情况出现，必须通过配置来指定IP的两台服务器间进行通讯（阿里说明文档中解释只能支持两台使用同一个HAVIP地址），基于以下方法可以的情况下，多备方式用同样的方式也应该可行，有需要的兄弟可以测试下多IP备的方式（正常情况需要主备一对主备就够了）。
在网卡配置后面需要加上以下配置：
unicast_src_ip  192.168.1.21	##（本地IP地址）
unicast_peer {
		192.168.1.22	##（对端IP地址）此地址一定不能忘记
}

之前我们用keepalived做集群时一般使用它构建服务器主从，也就是只有一个vip，并且这个vip只是在主节点上，当主节点宕机时，vip漂移到从节点上，从而实现高可用。但随着业务的发展，单个节点随之成为业务的性能瓶颈，及时我们使用的负载均衡再强大，服务器配置再高，也不可能单节点抗住所有流量。而通过这种方案，在keepalived的主从基础上扩展一下，通过配置多个vip，每个keepalived节点互为主从，正常情况下保证所有服务器都能拥有一个vip，然后通过dns负载均衡技术，将业务流量转发到每个vip。从而在一定程度上避免了单服务器的性能瓶颈。
```

## 2019-6-4

```
给进入 eth0 的包打包 mark 的标记，当数据包是发给 VIP:80 并且 MAC 不是其它 LVS 服务器的话。才做个 mark，这样才会对指定的 fwmark 进行 loadbalance 放入到 LVS 中处理。只要数据包是从任意其它的 MAC 地址（非 LVS 的转发）会被发往 VIP:port，会不在进行 loadbalanced 而是直接转给后面监听的 demon 程序进行应用的处理。实际就是使用 iptables 来对进入的流量设置 MARK。然后配置 keepalived 只处理有 MARK 过的流量。不在使用以前绑定的 VIP 和端口

# iptables  -t mangle -I PREROUTING -d $VIP -p tcp -m tcp --dport $VPORT -m mac ! --mac-source $MAC_Director2 -j MARK --set-mark 0x3
$VIP 为VIP地址
$VPORT 为服务端口
$MAC_Director2 是备机的MAC (keepalived 之间互相监听的那块网卡)

# iptables  -t mangle -I PREROUTING -d 192.168.23.253 -p tcp -m tcp --dport 80 -m mac ! --mac-source 08:00:27:46:c7:d4 -j MARK --set-mark 0x3
# iptables  -t mangle -I PREROUTING -d 192.168.23.253 -p tcp -m tcp --dport 80 -m mac ! --mac-source 08:00:27:9e:ef:a0 -j MARK --set-mark 0x4

ipvs的防火墙打标，实现基于防火墙的负载均衡集群
# virtual_server fwmark int

http://www.linuxyw.com/linux/fuzaijunheng/20130429/146.html
```

